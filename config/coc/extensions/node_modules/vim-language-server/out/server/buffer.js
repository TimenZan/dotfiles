"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var logger_1 = tslib_1.__importDefault(require("../common/logger"));
var vscode_languageserver_1 = require("vscode-languageserver");
var constant_1 = require("../common/constant");
var log = logger_1.default('buffer');
var NODE_TOPLEVEL = 1;
var NODE_EXCMD = 3; // TODO
var NODE_FUNCTION = 4;
var NODE_DELFUNCTION = 6;
var NODE_RETURN = 7;
var NODE_EXCALL = 8;
var NODE_LET = 9;
var NODE_UNLET = 10;
var NODE_LOCKVAR = 11;
var NODE_UNLOCKVAR = 12;
var NODE_IF = 13;
var NODE_ELSEIF = 14;
var NODE_ELSE = 15;
var NODE_WHILE = 17;
var NODE_FOR = 19;
var NODE_TRY = 23;
var NODE_CATCH = 24;
var NODE_FINALLY = 25;
var NODE_THROW = 27;
var NODE_ECHO = 28;
var NODE_ECHON = 29;
var NODE_ECHOMSG = 31;
var NODE_ECHOERR = 32;
var NODE_EXECUTE = 33;
var NODE_TERNARY = 34;
var NODE_OR = 35;
var NODE_AND = 36;
var NODE_EQUAL = 37;
var NODE_EQUALCI = 38;
var NODE_EQUALCS = 39;
var NODE_NEQUAL = 40;
var NODE_NEQUALCI = 41;
var NODE_NEQUALCS = 42;
var NODE_GREATER = 43;
var NODE_GREATERCI = 44;
var NODE_GREATERCS = 45;
var NODE_GEQUAL = 46;
var NODE_GEQUALCI = 47;
var NODE_GEQUALCS = 48;
var NODE_SMALLER = 49;
var NODE_SMALLERCI = 50;
var NODE_SMALLERCS = 51;
var NODE_SEQUAL = 52;
var NODE_SEQUALCI = 53;
var NODE_SEQUALCS = 54;
var NODE_MATCH = 55;
var NODE_MATCHCI = 56;
var NODE_MATCHCS = 57;
var NODE_NOMATCH = 58;
var NODE_NOMATCHCI = 59;
var NODE_NOMATCHCS = 60;
var NODE_IS = 61;
var NODE_ISCI = 62;
var NODE_ISCS = 63;
var NODE_ISNOT = 64;
var NODE_ISNOTCI = 65;
var NODE_ISNOTCS = 66;
var NODE_ADD = 67;
var NODE_SUBTRACT = 68;
var NODE_CONCAT = 69;
var NODE_MULTIPLY = 70;
var NODE_DIVIDE = 71;
var NODE_REMAINDER = 72;
var NODE_NOT = 73;
var NODE_MINUS = 74;
var NODE_PLUS = 75;
var NODE_SUBSCRIPT = 76;
var NODE_SLICE = 77;
var NODE_CALL = 78;
var NODE_DOT = 79;
var NODE_NUMBER = 80;
var NODE_STRING = 81;
var NODE_LIST = 82;
var NODE_DICT = 83;
var NODE_IDENTIFIER = 86;
var NODE_CURLYNAME = 87;
var NODE_ENV = 88;
var NODE_REG = 89; // TODO
var NODE_CURLYNAMEPART = 90; // TODO
var NODE_CURLYNAMEEXPR = 91; // TODO
var NODE_LAMBDA = 92;
var globalFuncPattern = /^(g:\w+(\.\w+)*|[a-zA-Z](\.\w+)*|[a-zA-Z]\w+(\.\w+)*|\w+(#\w+)+)$/;
var scriptFuncPattern = /^(s:\w+(\.\w+)*|<SID>\w+(\.\w+)*)$/i;
var globalVariablePattern = /^(g:\w+(\.\w+)*|b:\w+(\.\w+)*|\w{1,}(\.\w+)*|\w+(#\w+)+)$/;
var localVariablePattern = /^(s:\w+(\.\w+)*|l:\w+(\.\w+)*|a:\w+(\.\w+)*)$/;
var envPattern = /^\$\w+$/;
var Buffer = /** @class */ (function () {
    function Buffer(uri, workDir, node) {
        this.uri = uri;
        this.workDir = workDir;
        this.node = node;
        this.globalFunctions = {};
        this.scriptFunctions = {};
        this.globalFunctionRefs = {};
        this.scriptFunctionRefs = {};
        this.globalVariables = {};
        this.localVariables = {};
        this.globalVariableRefs = {};
        this.localVariableRefs = {};
        this.envs = {};
        this.envRefs = {};
        this.updateBufferByNode(this.node);
    }
    Buffer.prototype.getGlobalFunctions = function () {
        return this.globalFunctions;
    };
    Buffer.prototype.getGlobalFunctionRefs = function () {
        return this.globalFunctionRefs;
    };
    Buffer.prototype.getScriptFunctions = function () {
        return this.scriptFunctions;
    };
    Buffer.prototype.getScriptFunctionRefs = function () {
        return this.scriptFunctionRefs;
    };
    Buffer.prototype.getGlobalIdentifiers = function () {
        return this.globalVariables;
    };
    Buffer.prototype.getGlobalIdentifierRefs = function () {
        return this.globalVariableRefs;
    };
    Buffer.prototype.getLocalIdentifiers = function () {
        return this.localVariables;
    };
    Buffer.prototype.getLocalIdentifierRefs = function () {
        return this.localVariableRefs;
    };
    Buffer.prototype.getWorkDir = function () {
        return this.workDir;
    };
    Buffer.prototype.isBelongToWorkdir = function (workUri) {
        return this.workDir === workUri;
    };
    Buffer.prototype.updateBufferByNode = function (node) {
        this.node = node;
        this.resetProperties();
        try {
            this.resolveCompletionItems([node]);
        }
        catch (error) {
            log.error(error.stack);
        }
    };
    Buffer.prototype.resetProperties = function () {
        this.globalFunctions = {};
        this.scriptFunctions = {};
        this.globalFunctionRefs = {};
        this.scriptFunctionRefs = {};
        this.globalVariables = {};
        this.localVariables = {};
        this.globalVariableRefs = {};
        this.localVariableRefs = {};
        this.envs = {};
        this.envRefs = {};
    };
    Buffer.prototype.resolveCompletionItems = function (nodes) {
        var nodeList = [].concat(nodes);
        while (nodeList.length > 0) {
            var node = nodeList.pop();
            switch (node.type) {
                case NODE_TOPLEVEL:
                    nodeList = nodeList.concat(node.body);
                    break;
                case NODE_EXCALL:
                case NODE_RETURN:
                case NODE_DELFUNCTION:
                case NODE_THROW:
                    nodeList = nodeList.concat(node.left);
                    break;
                case NODE_DOT:
                    nodeList = nodeList.concat(node.left);
                    this.takeIdentifier(node);
                    break;
                case NODE_ECHO:
                case NODE_ECHON:
                case NODE_ECHOMSG:
                case NODE_ECHOERR:
                case NODE_UNLET:
                case NODE_LOCKVAR:
                case NODE_UNLOCKVAR:
                case NODE_EXECUTE:
                    nodeList = nodeList.concat(node.list || []);
                    break;
                case NODE_TERNARY:
                    nodeList = nodeList.concat(node.cond || []);
                    nodeList = nodeList.concat(node.left || []);
                    nodeList = nodeList.concat(node.right || []);
                    break;
                case NODE_IF:
                case NODE_ELSEIF:
                case NODE_ELSE:
                case NODE_WHILE:
                    nodeList = nodeList.concat(node.body || []);
                    nodeList = nodeList.concat(node.cond || []);
                    nodeList = nodeList.concat(node.elseif || []);
                    nodeList = nodeList.concat(node._else || []);
                    break;
                case NODE_OR:
                case NODE_AND:
                case NODE_EQUAL:
                case NODE_EQUALCI:
                case NODE_EQUALCS:
                case NODE_NEQUAL:
                case NODE_NEQUALCI:
                case NODE_NEQUALCS:
                case NODE_GREATER:
                case NODE_GREATERCI:
                case NODE_GREATERCS:
                case NODE_GEQUAL:
                case NODE_GEQUALCI:
                case NODE_GEQUALCS:
                case NODE_SMALLER:
                case NODE_SMALLERCI:
                case NODE_SMALLERCS:
                case NODE_SEQUAL:
                case NODE_SEQUALCI:
                case NODE_SEQUALCS:
                case NODE_MATCH:
                case NODE_MATCHCI:
                case NODE_MATCHCS:
                case NODE_NOMATCH:
                case NODE_NOMATCHCI:
                case NODE_NOMATCHCS:
                case NODE_IS:
                case NODE_ISCI:
                case NODE_ISCS:
                case NODE_ISNOT:
                case NODE_ISNOTCI:
                case NODE_ISNOTCS:
                case NODE_CONCAT:
                case NODE_MULTIPLY:
                case NODE_DIVIDE:
                case NODE_REMAINDER:
                case NODE_NOT:
                case NODE_MINUS:
                case NODE_PLUS:
                case NODE_ADD:
                case NODE_SUBTRACT:
                case NODE_SUBSCRIPT:
                    nodeList = nodeList.concat(node.left || []);
                    nodeList = nodeList.concat(node.right || []);
                    break;
                case NODE_FOR:
                    nodeList = nodeList.concat(node.body || []);
                    nodeList = nodeList.concat(node.right || []);
                    this.takeFor([].concat(node.left || []).concat(node.list || []));
                    break;
                case NODE_TRY:
                case NODE_CATCH:
                case NODE_FINALLY:
                    nodeList = nodeList.concat(node.body || []);
                    nodeList = nodeList.concat(node.catch || []);
                    nodeList = nodeList.concat(node._finally || []);
                    break;
                case NODE_FUNCTION:
                    nodeList = nodeList.concat(node.body || []);
                    if (node.left && node.left.type === NODE_DOT) {
                        nodeList = nodeList.concat(node.left.left);
                    }
                    this.takeFunction(node);
                    break;
                case NODE_LIST:
                    nodeList = nodeList.concat(node.value || []);
                    break;
                case NODE_DICT:
                    nodeList = nodeList.concat((node.value || []).map(function (item) { return item[1]; }));
                    break;
                case NODE_SLICE:
                case NODE_LAMBDA:
                    nodeList = nodeList.concat(node.left || []);
                    nodeList = nodeList.concat(node.rlist || []);
                    break;
                case NODE_CALL:
                    nodeList = nodeList.concat(node.rlist || []);
                    if (node.left && node.left.type === NODE_DOT) {
                        nodeList = nodeList.concat(node.left.left);
                    }
                    this.takeFuncRef(node);
                    break;
                case NODE_LET:
                    nodeList = nodeList.concat(node.right || []);
                    if (node.left && node.left.type === NODE_DOT) {
                        nodeList = nodeList.concat(node.left.left);
                    }
                    this.takeLet(node);
                    break;
                case NODE_ENV:
                case NODE_IDENTIFIER:
                    this.takeIdentifier(node);
                    break;
                default:
                    break;
            }
        }
        // log.info(`parse_buffer: ${JSON.stringify(this)}`)
    };
    Buffer.prototype.takeFunction = function (node) {
        var left = node.left, rlist = node.rlist, endfunction = node.endfunction;
        var name = this.getDotName(left);
        if (!name) {
            return;
        }
        var pos = this.getDotPos(left);
        if (!pos) {
            return;
        }
        var func = {
            name: name,
            args: rlist || [],
            startLine: pos.lnum,
            startCol: pos.col,
            endLine: endfunction.pos.lnum,
            endCol: endfunction.pos.col
        };
        if (globalFuncPattern.test(name)) {
            if (!this.globalFunctions[name] || !Array.isArray(this.globalFunctions[name])) {
                this.globalFunctions[name] = [];
            }
            this.globalFunctions[name].push(func);
        }
        else if (scriptFuncPattern.test(name)) {
            if (!this.scriptFunctions[name] || !Array.isArray(this.scriptFunctions[name])) {
                this.scriptFunctions[name] = [];
            }
            this.scriptFunctions[name].push(func);
        }
    };
    Buffer.prototype.takeFuncRef = function (node) {
        var left = node.left, rlist = node.rlist;
        var name = '';
        if (left.type === NODE_IDENTIFIER) {
            name = left.value;
            // <SID>funName
        }
        else if (left.type === NODE_CURLYNAME) {
            name = (left.value || []).map(function (item) { return item.value; }).join('');
        }
        else if (left.type === NODE_DOT) {
            name = this.getDotName(left);
        }
        if (!name) {
            return;
        }
        var pos = this.getDotPos(left);
        if (!pos) {
            return;
        }
        var funcRef = {
            name: name,
            args: rlist || [],
            startLine: pos.lnum,
            startCol: pos.col
        };
        if (globalFuncPattern.test(name)) {
            if (!this.globalFunctionRefs[name] || !Array.isArray(this.globalFunctionRefs[name])) {
                this.globalFunctionRefs[name] = [];
            }
            this.globalFunctionRefs[name].push(funcRef);
        }
        else if (scriptFuncPattern.test(name)) {
            if (!this.scriptFunctionRefs[name] || !Array.isArray(this.scriptFunctionRefs[name])) {
                this.scriptFunctionRefs[name] = [];
            }
            this.scriptFunctionRefs[name].push(funcRef);
        }
    };
    Buffer.prototype.takeLet = function (node) {
        var pos = this.getDotPos(node.left);
        var name = this.getDotName(node.left);
        if (!pos || !name) {
            return;
        }
        var identifier = {
            name: name,
            startLine: pos.lnum,
            startCol: pos.col
        };
        if (localVariablePattern.test(name)) {
            if (!this.localVariables[name] || !Array.isArray(this.localVariables[name])) {
                this.localVariables[name] = [];
            }
            this.localVariables[name].push(identifier);
        }
        else if (globalVariablePattern.test(name)) {
            if (!this.globalVariables[name] || !Array.isArray(this.globalVariables[name])) {
                this.globalVariables[name] = [];
            }
            this.globalVariables[name].push(identifier);
        }
        else if (envPattern.test(name)) {
            if (!this.envs[name] || !Array.isArray(this.envs[name])) {
                this.envs[name] = [];
            }
            this.envs[name].push(identifier);
        }
    };
    Buffer.prototype.takeFor = function (nodes) {
        var _this = this;
        nodes.forEach(function (node) {
            if (node.type !== NODE_IDENTIFIER || !node.pos) {
                return;
            }
            var name = node.value;
            var identifier = {
                name: name,
                startLine: node.pos.lnum,
                startCol: node.pos.col
            };
            if (localVariablePattern.test(name)) {
                if (!_this.localVariables[name] || !Array.isArray(_this.localVariables[name])) {
                    _this.localVariables[name] = [];
                }
                _this.localVariables[name].push(identifier);
            }
            else if (globalVariablePattern.test(name)) {
                if (!_this.globalVariables[name] || !Array.isArray(_this.globalVariables[name])) {
                    _this.globalVariables[name] = [];
                }
                _this.globalVariables[name].push(identifier);
            }
            else if (envPattern.test(name)) {
                if (!_this.envs[name] || !Array.isArray(_this.envs[name])) {
                    _this.envs[name] = [];
                }
                _this.envs[name].push(identifier);
            }
        });
    };
    Buffer.prototype.takeIdentifier = function (node) {
        var name = this.getDotName(node);
        if (!name) {
            return;
        }
        var pos = this.getDotPos(node);
        if (!pos) {
            return;
        }
        var identifier = {
            name: name,
            startLine: pos.lnum,
            startCol: pos.col
        };
        if (globalVariablePattern.test(name)) {
            if (!this.globalVariableRefs[name] || !Array.isArray(this.globalVariableRefs[name])) {
                this.globalVariableRefs[name] = [];
            }
            this.globalVariableRefs[name].push(identifier);
        }
        else if (localVariablePattern.test(name)) {
            if (!this.localVariableRefs[name] || !Array.isArray(this.localVariableRefs[name])) {
                this.localVariableRefs[name] = [];
            }
            this.localVariableRefs[name].push(identifier);
        }
        else if (envPattern.test(name)) {
            if (!this.envRefs[name] || !Array.isArray(this.envRefs[name])) {
                this.envRefs[name] = [];
            }
            this.envRefs[name].push(identifier);
        }
    };
    Buffer.prototype.getDotPos = function (node) {
        if (!node) {
            return null;
        }
        if (node.type === NODE_IDENTIFIER ||
            node.type === NODE_ENV ||
            node.type === NODE_CURLYNAME) {
            return node.pos;
        }
        var left = node.left;
        return this.getDotPos(left);
    };
    Buffer.prototype.getDotName = function (node) {
        if (node.type === NODE_IDENTIFIER ||
            node.type === NODE_STRING ||
            node.type === NODE_NUMBER ||
            node.type === NODE_ENV) {
            return node.value;
        }
        else if (node.type === NODE_CURLYNAME) {
            return (node.value || []).map(function (item) { return item.value; }).join('');
        }
        else if (node.type === NODE_SUBSCRIPT) {
            return this.getDotName(node.left);
        }
        var left = node.left, right = node.right;
        var list = [];
        if (left) {
            list.push(this.getDotName(left));
        }
        if (right) {
            list.push(this.getDotName(right));
        }
        return list.join('.');
    };
    Buffer.prototype.getFunctionItems = function (items, sortText) {
        return Object.keys(items).map(function (name) {
            var list = items[name];
            var args = '${1}';
            if (list[0] && list[0].args && list[0].args.length > 0) {
                args = (list[0].args || []).reduce(function (res, next, idx) {
                    // FIXME: resove next.value is not string
                    var value = typeof next.value !== 'string' ? 'param' : next.value;
                    if (idx === 0) {
                        return "${" + (idx + 1) + ":" + value + "}";
                    }
                    return res + ", ${" + (idx + 1) + ":" + value + "}";
                }, '');
            }
            var label = name;
            if (/^<SID>/.test(name)) {
                label = name.replace(/^<SID>/, 's:');
            }
            return {
                label: label,
                detail: 'any',
                sortText: sortText,
                documentation: 'User defined function',
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                insertText: label + "(" + args + ")${0}",
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet
            };
        });
    };
    Buffer.prototype.getIdentifierItems = function (items, sortText) {
        var _this = this;
        return Object.keys(items)
            .filter(function (name) { return !_this.globalFunctions[name] && !_this.scriptFunctions[name]; })
            .map(function (name) {
            var list = items[name];
            return {
                label: name,
                kind: vscode_languageserver_1.CompletionItemKind.Variable,
                sortText: sortText,
                documentation: 'User defined variable',
                insertText: name,
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
                data: list || []
            };
        });
    };
    /*
     * global function
     *
     * - g:xxx
     * - xx#xxx
     */
    Buffer.prototype.getGlobalFunctionItems = function () {
        var _this = this;
        var refs = {};
        Object.keys(this.globalFunctionRefs).forEach(function (name) {
            if (!_this.globalFunctions[name]) {
                refs[name] = _this.globalFunctionRefs[name];
            }
        });
        return this.getFunctionItems(this.globalFunctions, constant_1.sortTexts.three)
            .concat(this.getFunctionItems(refs, constant_1.sortTexts.three));
    };
    /*
     * script function
     *
     * - s:xxx
     */
    Buffer.prototype.getScriptFunctionItems = function () {
        var _this = this;
        var refs = {};
        Object.keys(this.scriptFunctionRefs).forEach(function (name) {
            if (!_this.scriptFunctions[name]) {
                refs[name] = _this.scriptFunctionRefs[name];
            }
        });
        return this.getFunctionItems(this.scriptFunctions, constant_1.sortTexts.two)
            .concat(this.getFunctionItems(refs, constant_1.sortTexts.two));
    };
    /*
     * global identifier
     *
     * - g:xxx
     * - b:xxx
     * - [a-zA-Z]+
     * - xx#xxx
     */
    Buffer.prototype.getGlobalIdentifierItems = function () {
        var _this = this;
        var refs = {};
        Object.keys(this.globalVariableRefs).forEach(function (name) {
            if (!_this.globalVariables[name]) {
                refs[name] = _this.globalVariableRefs[name];
            }
        });
        var globalVariables = [];
        var localVariables = [];
        this.getIdentifierItems(this.globalVariables, constant_1.sortTexts.three)
            .concat(this.getIdentifierItems(refs, constant_1.sortTexts.three))
            .forEach(function (item) {
            if (/^([a-zA-Z](\.\w+)*|[a-zA-Z]\w+(\.\w+)*)$/.test(item.label)) {
                localVariables.push(item);
            }
            else {
                globalVariables.push(item);
            }
        });
        if (localVariables.length) {
            var gloalFunctions = this.getGlobalFunctions();
            var scriptFunctions = this.getScriptFunctions();
            var funList_1 = Object.values(gloalFunctions).concat(Object.values(scriptFunctions)).reduce(function (res, fs) { return res.concat(fs); }, []);
            localVariables.forEach(function (l) {
                if (l.data.some(function (identifier) {
                    return funList_1.every(function (fun) { return !(fun.startLine < identifier.startLine && identifier.startLine < fun.endLine); });
                })) {
                    globalVariables.push(l);
                }
            });
        }
        return globalVariables;
    };
    /*
     * local identifier
     *
     * - s:xxx
     */
    Buffer.prototype.getLocalIdentifierItems = function () {
        var _this = this;
        var refs = {};
        Object.keys(this.localVariableRefs).forEach(function (name) {
            if (!_this.localVariables[name]) {
                refs[name] = _this.localVariableRefs[name];
            }
        });
        return this.getIdentifierItems(this.localVariables, constant_1.sortTexts.two)
            .concat(this.getIdentifierItems(refs, constant_1.sortTexts.two))
            .filter(function (item) { return !/^(a|l):/.test(item.label); });
    };
    /*
     * function local identifier
     *
     * - l:xxx
     * - a:xxx
     */
    Buffer.prototype.getFunctionLocalIdentifierItems = function (line) {
        var vimLineNum = line + 1;
        var startLine = -1;
        var endLine = -1;
        // get function args completion items
        var funArgs = []
            .concat(Object.values(this.globalFunctions).reduce(function (res, next) { return res.concat(next); }, []))
            .concat(Object.values(this.scriptFunctions).reduce(function (res, next) { return res.concat(next); }, []))
            .filter(function (fun) {
            if (startLine === -1 && endLine === -1 && fun.startLine < vimLineNum && vimLineNum < fun.endLine) {
                startLine = fun.startLine;
                endLine = fun.endLine;
            }
            else if (fun.startLine > startLine && endLine > fun.endLine) {
                startLine = fun.startLine;
                endLine = fun.endLine;
            }
            return fun.startLine < vimLineNum && vimLineNum < fun.endLine;
        })
            .reduce(function (res, next) {
            (next.args || []).forEach(function (name) {
                if (res.indexOf(name.value) === -1) {
                    res.push(name.value);
                }
            });
            return res;
        }, [])
            .map(function (name) { return ({
            label: "a:" + name,
            kind: vscode_languageserver_1.CompletionItemKind.Variable,
            sortText: constant_1.sortTexts.one,
            insertText: "a:" + name,
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText
        }); });
        if (startLine !== -1 && endLine !== -1) {
            var funcLocalIdentifiers = this.getIdentifierItems(this.localVariables, constant_1.sortTexts.one)
                .filter(function (item) {
                if (!/^l:/.test(item.label)) {
                    return false;
                }
                var data = item.data;
                if (!data) {
                    return false;
                }
                return data.some(function (i) { return startLine < i.startLine && i.startLine < endLine; });
            });
            return funArgs.concat(funcLocalIdentifiers);
        }
        return [];
    };
    /*
     * environment identifier
     *
     * - $xxx
     */
    Buffer.prototype.getEnvItems = function () {
        return Object.keys(this.envs).map(function (name) {
            return {
                label: name,
                insertText: name,
                sortText: constant_1.sortTexts.three,
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText
            };
        });
    };
    return Buffer;
}());
exports.Buffer = Buffer;
//# sourceMappingURL=buffer.js.map