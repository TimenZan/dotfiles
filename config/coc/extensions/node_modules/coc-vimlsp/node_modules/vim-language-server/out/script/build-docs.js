"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/*
 * vim builtin completion items
 *
 * 1. functions
 * 2. options
 * 3. variables
 * 4. commands
 * 5. has features
 * 6. expand Keyword
 */
var fs_1 = require("fs");
var path_1 = require("path");
var util_1 = require("../common/util");
var vscode_languageserver_1 = require("vscode-languageserver");
var constant_1 = require("../common/constant");
var EVAL_PATH = '/doc/eval.txt';
var OPTIONS_PATH = '/doc/options.txt';
var INDEX_PATH = '/doc/index.txt';
var API_PATH = '/doc/api.txt';
var Server = /** @class */ (function () {
    function Server(config) {
        this.config = config;
        // raw docs
        this.text = {};
        // completion items
        this.vimPredefinedVariablesItems = [];
        this.vimOptionItems = [];
        this.vimBuiltinFunctionItems = [];
        this.vimCommandItems = [];
        this.vimFeatureItems = [];
        this.vimExpandKeywordItems = [];
        // documents
        this.vimBuiltFunctionDocuments = {};
        this.vimOptionDocuments = {};
        this.vimPredefinedVariableDocuments = {};
        this.vimCommandDocuments = {};
        this.vimFeatureDocuments = {};
        this.expandKeywordDocuments = {};
        // signature help
        this.vimBuiltFunctionSignatureHelp = {};
    }
    Server.prototype.build = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var vimruntime, paths, index, p, _a, err, data;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        vimruntime = this.config.vimruntime;
                        if (!vimruntime) return [3 /*break*/, 5];
                        paths = [EVAL_PATH, OPTIONS_PATH, INDEX_PATH, API_PATH];
                        index = 0;
                        _b.label = 1;
                    case 1:
                        if (!(index < paths.length)) return [3 /*break*/, 4];
                        p = path_1.join(vimruntime, paths[index]);
                        return [4 /*yield*/, util_1.pcb(fs_1.readFile)(p, 'utf-8')];
                    case 2:
                        _a = _b.sent(), err = _a[0], data = _a[1];
                        if (err) {
                            console.error("[vimls]: read " + p + " error: " + err.message);
                        }
                        this.text[paths[index]] = (data && data.toString().split('\n')) || [];
                        _b.label = 3;
                    case 3:
                        index++;
                        return [3 /*break*/, 1];
                    case 4:
                        this.resolveVimPredefinedVariables();
                        this.resolveVimOptions();
                        this.resolveBuiltinFunctions();
                        this.resolveBuiltinFunctionsDocument();
                        this.resolveBuiltinNvimFunctions();
                        this.resolveExpandKeywords();
                        this.resolveVimCommands();
                        this.resolveVimFeatures();
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    Server.prototype.serialize = function () {
        var str = JSON.stringify({
            completionItems: {
                commands: this.vimCommandItems,
                functions: this.vimBuiltinFunctionItems,
                variables: this.vimPredefinedVariablesItems,
                options: this.vimOptionItems,
                features: this.vimFeatureItems,
                expandKeywords: this.vimExpandKeywordItems,
            },
            signatureHelp: this.vimBuiltFunctionSignatureHelp,
            documents: {
                commands: this.vimCommandDocuments,
                functions: this.vimBuiltFunctionDocuments,
                variables: this.vimPredefinedVariableDocuments,
                options: this.vimOptionDocuments,
                features: this.vimFeatureDocuments,
                expandKeywords: this.expandKeywordDocuments
            }
        }, null, 2);
        fs_1.writeFileSync('./docs/builtin-docs.json', str, 'utf-8');
    };
    Server.prototype.formatFunctionSnippets = function (fname, snippets) {
        if (snippets === '') {
            return fname + "(${0})";
        }
        var idx = 0;
        if (/^\[.+\]/.test(snippets)) {
            return fname + "(${1})${0}";
        }
        var str = snippets.split('[')[0].trim().replace(/\{?(\w+)\}?/g, function (m, g1) {
            return "${" + (idx += 1) + ":" + g1 + "}";
        });
        return fname + "(" + str + ")${0}";
    };
    // get vim predefined variables from vim document eval.txt
    Server.prototype.resolveVimPredefinedVariables = function () {
        var evalText = this.text[EVAL_PATH] || [];
        var isMatchLine = false;
        var completionItem;
        for (var idx = 0; idx < evalText.length; idx++) {
            var line = evalText[idx];
            if (!isMatchLine) {
                if (/\*vim-variable\*/.test(line)) {
                    isMatchLine = true;
                }
                continue;
            }
            else {
                var m = line.match(/^(v:[^ \t]+)[ \t]+([^ ].*)$/);
                if (m) {
                    if (completionItem) {
                        this.vimPredefinedVariablesItems.push(completionItem);
                        this.vimPredefinedVariableDocuments[completionItem.label].pop();
                        completionItem = undefined;
                    }
                    var label = m[1];
                    completionItem = {
                        label: label,
                        kind: vscode_languageserver_1.CompletionItemKind.Variable,
                        sortText: constant_1.sortTexts.four,
                        insertText: label.slice(2),
                        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText
                    };
                    if (!this.vimPredefinedVariableDocuments[label]) {
                        this.vimPredefinedVariableDocuments[label] = [];
                    }
                    this.vimPredefinedVariableDocuments[label].push(m[2]);
                }
                else if (/^\s*$/.test(line) && completionItem) {
                    this.vimPredefinedVariablesItems.push(completionItem);
                    completionItem = undefined;
                }
                else if (completionItem) {
                    this.vimPredefinedVariableDocuments[completionItem.label].push(line);
                }
                else if (/===============/.test(line)) {
                    break;
                }
            }
        }
    };
    // get vim options from vim document options.txt
    Server.prototype.resolveVimOptions = function () {
        var optionsText = this.text[OPTIONS_PATH] || [];
        var isMatchLine = false;
        var completionItem;
        for (var idx = 0; idx < optionsText.length; idx++) {
            var line = optionsText[idx];
            if (!isMatchLine) {
                if (/\*'aleph'\*/.test(line)) {
                    isMatchLine = true;
                }
                continue;
            }
            else {
                var m = line.match(/^'([^']+)'[ \t]+('[^']+')?[ \t]+([^ \t].*)$/);
                if (m) {
                    var label = m[1];
                    completionItem = {
                        label: label,
                        kind: vscode_languageserver_1.CompletionItemKind.Property,
                        detail: m[3].trim().split(/[ \t]/)[0],
                        documentation: '',
                        sortText: '00004',
                        insertText: m[1],
                        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText
                    };
                    if (!this.vimOptionDocuments[label]) {
                        this.vimOptionDocuments[label] = [];
                    }
                    this.vimOptionDocuments[label].push(m[3]);
                }
                else if (/^\s*$/.test(line) && completionItem) {
                    this.vimOptionItems.push(completionItem);
                    completionItem = undefined;
                }
                else if (completionItem) {
                    this.vimOptionDocuments[completionItem.label].push(line);
                }
            }
        }
    };
    // get vim builtin function from document eval.txt
    Server.prototype.resolveBuiltinFunctions = function () {
        var evalText = this.text[EVAL_PATH] || [];
        var isMatchLine = false;
        var completionItem;
        for (var idx = 0; idx < evalText.length; idx++) {
            var line = evalText[idx];
            if (!isMatchLine) {
                if (/\*functions\*/.test(line)) {
                    isMatchLine = true;
                }
                continue;
            }
            else {
                var m = line.match(/^((\w+)\(([^)]*)\))[ \t]*([^ \t].*)?$/);
                if (m) {
                    if (completionItem) {
                        this.vimBuiltinFunctionItems.push(completionItem);
                    }
                    var label = m[2];
                    completionItem = {
                        label: label,
                        kind: vscode_languageserver_1.CompletionItemKind.Function,
                        detail: (m[4] || '').split(/[ \t]/)[0],
                        sortText: '00004',
                        insertText: this.formatFunctionSnippets(m[2], m[3]),
                        insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet
                    };
                    this.vimBuiltFunctionSignatureHelp[label] = [
                        m[3],
                        (m[4] || '').split(/[ \t]/)[0]
                    ];
                }
                else if (/^[ \t]*$/.test(line)) {
                    if (completionItem) {
                        this.vimBuiltinFunctionItems.push(completionItem);
                        completionItem = undefined;
                        break;
                    }
                }
                else if (completionItem) {
                    if (completionItem.detail === '') {
                        completionItem.detail = line.trim().split(/[ \t]/)[0];
                        if (this.vimBuiltFunctionSignatureHelp[completionItem.label]) {
                            this.vimBuiltFunctionSignatureHelp[completionItem.label][1] = line.trim().split(/[ \t]/)[0];
                        }
                    }
                }
            }
        }
    };
    Server.prototype.resolveBuiltinFunctionsDocument = function () {
        var evalText = this.text[EVAL_PATH] || [];
        var isMatchLine = false;
        var label = '';
        for (var idx = 0; idx < evalText.length; idx++) {
            var line = evalText[idx];
            if (!isMatchLine) {
                if (/\*abs\(\)\*/.test(line)) {
                    isMatchLine = true;
                    idx -= 1;
                }
                continue;
            }
            else {
                var m = line.match(/^((\w+)\(([^)]*)\))[ \t]*([^ \t].*)?$/);
                if (m) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    label = m[2];
                    if (!this.vimBuiltFunctionDocuments[label]) {
                        this.vimBuiltFunctionDocuments[label] = [];
                    }
                }
                else if (/^[ \t]*\*string-match\*[ \t]*$/.test(line)) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    break;
                }
                else if (label) {
                    this.vimBuiltFunctionDocuments[label].push(line);
                }
            }
        }
    };
    Server.prototype.resolveBuiltinNvimFunctions = function () {
        var evalText = this.text[API_PATH] || [];
        var completionItem;
        for (var idx = 0; idx < evalText.length; idx++) {
            var line = evalText[idx];
            var m = line.match(/^((nvim_\w+)\(([^)]*)\))[ \t]*/);
            if (m) {
                if (completionItem) {
                    this.vimBuiltinFunctionItems.push(completionItem);
                    if (this.vimBuiltFunctionDocuments[completionItem.label]) {
                        this.vimBuiltFunctionDocuments[completionItem.label].pop();
                    }
                }
                var label = m[2];
                completionItem = {
                    label: label,
                    kind: vscode_languageserver_1.CompletionItemKind.Function,
                    detail: '',
                    documentation: '',
                    sortText: '00004',
                    insertText: this.formatFunctionSnippets(m[2], m[3]),
                    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet
                };
                if (!this.vimBuiltFunctionDocuments[label]) {
                    this.vimBuiltFunctionDocuments[label] = [];
                }
                this.vimBuiltFunctionSignatureHelp[label] = [
                    m[3],
                    ''
                ];
            }
            else if (/^(================|[ \t]*vim:tw=78:ts=8:ft=help:norl:)/.test(line)) {
                if (completionItem) {
                    this.vimBuiltinFunctionItems.push(completionItem);
                    if (this.vimBuiltFunctionDocuments[completionItem.label]) {
                        this.vimBuiltFunctionDocuments[completionItem.label].pop();
                    }
                    completionItem = undefined;
                }
            }
            else if (completionItem) {
                this.vimBuiltFunctionDocuments[completionItem.label].push(line);
            }
        }
    };
    Server.prototype.resolveVimCommands = function () {
        var indexText = this.text[INDEX_PATH] || [];
        var isMatchLine = false;
        var completionItem;
        for (var idx = 0; idx < indexText.length; idx++) {
            var line = indexText[idx];
            if (!isMatchLine) {
                if (/\*ex-cmd-index\*/.test(line)) {
                    isMatchLine = true;
                }
                continue;
            }
            else {
                var m = line.match(/^\|?:([^ \t]+?)\|?[ \t]+:([^ \t]+)[ \t]+([^ \t].*)$/);
                if (m) {
                    if (completionItem) {
                        this.vimCommandItems.push(completionItem);
                    }
                    var label = m[1];
                    completionItem = {
                        label: m[1],
                        kind: vscode_languageserver_1.CompletionItemKind.Operator,
                        detail: m[2],
                        documentation: m[3],
                        sortText: '00004',
                        insertText: m[1],
                        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText
                    };
                    if (!this.vimCommandDocuments[label]) {
                        this.vimCommandDocuments[label] = [];
                    }
                    this.vimCommandDocuments[label].push(m[3]);
                }
                else if (/^[ \t]*$/.test(line)) {
                    if (completionItem) {
                        this.vimCommandItems.push(completionItem);
                        completionItem = undefined;
                        break;
                    }
                }
                else if (completionItem) {
                    completionItem.documentation += " " + line.trim();
                    this.vimCommandDocuments[completionItem.label].push(line);
                }
            }
        }
    };
    Server.prototype.resolveVimFeatures = function () {
        var text = this.text[EVAL_PATH] || [];
        var isMatchLine = false;
        var completionItem;
        var features = [];
        for (var idx = 0; idx < text.length; idx++) {
            var line = text[idx];
            if (!isMatchLine) {
                if (/^[ \t]*acl[ \t]/.test(line)) {
                    isMatchLine = true;
                    idx -= 1;
                }
                continue;
            }
            else {
                var m = line.match(/^[ \t]*\*?([^ \t]+?)\*?[ \t]+([^ \t].*)$/);
                if (m) {
                    if (completionItem) {
                        features.push(completionItem);
                    }
                    var label = m[1];
                    completionItem = {
                        label: m[1],
                        kind: vscode_languageserver_1.CompletionItemKind.EnumMember,
                        documentation: '',
                        sortText: '00004',
                        insertText: m[1],
                        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText
                    };
                    if (!this.vimFeatureDocuments[label]) {
                        this.vimFeatureDocuments[label] = [];
                    }
                    this.vimFeatureDocuments[label].push(m[2]);
                }
                else if (/^[ \t]*$/.test(line)) {
                    if (completionItem) {
                        features.push(completionItem);
                        break;
                    }
                }
                else if (completionItem) {
                    this.vimFeatureDocuments[completionItem.label].push(line);
                }
            }
        }
        this.vimFeatureItems = features;
    };
    Server.prototype.resolveExpandKeywords = function () {
        var _this = this;
        this.vimExpandKeywordItems = [
            '<cfile>,file name under the cursor',
            '<afile>,autocmd file name',
            '<abuf>,autocmd buffer number (as a String!)',
            '<amatch>,autocmd matched name',
            '<sfile>,sourced script file or function name',
            '<slnum>,sourced script file line number',
            '<cword>,word under the cursor',
            '<cWORD>,WORD under the cursor',
            '<client>,the {clientid} of the last received message `server2client()`',
        ].map(function (line) {
            var item = line.split(',');
            _this.expandKeywordDocuments[item[0]] = [
                item[1]
            ];
            return {
                label: item[0],
                kind: vscode_languageserver_1.CompletionItemKind.Keyword,
                documentation: item[1],
                sortText: '00004',
                insertText: item[0],
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText
            };
        });
    };
    return Server;
}());
function main() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var servers, idx, server;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    servers = [];
                    idx = 2;
                    _a.label = 1;
                case 1:
                    if (!(idx < process.argv.length)) return [3 /*break*/, 4];
                    servers.push(new Server({
                        vimruntime: process.argv[idx],
                    }));
                    return [4 /*yield*/, servers[servers.length - 1].build()];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    idx++;
                    return [3 /*break*/, 1];
                case 4:
                    server = servers.reduce(function (pre, next) {
                        // merge functions
                        next.vimBuiltinFunctionItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.vimBuiltFunctionDocuments[label]) {
                                pre.vimBuiltinFunctionItems.push(item);
                                pre.vimBuiltFunctionDocuments[label] = next.vimBuiltFunctionDocuments[label];
                            }
                        });
                        // merge commands
                        next.vimCommandItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.vimCommandDocuments[label]) {
                                pre.vimCommandItems.push(item);
                                pre.vimCommandDocuments[label] = next.vimCommandDocuments[label];
                            }
                        });
                        // merge options
                        next.vimOptionItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.vimOptionDocuments[label]) {
                                pre.vimOptionItems.push(item);
                                pre.vimOptionDocuments[label] = next.vimOptionDocuments[label];
                            }
                        });
                        // merge variables
                        next.vimPredefinedVariablesItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.vimPredefinedVariableDocuments[label]) {
                                pre.vimPredefinedVariablesItems.push(item);
                                pre.vimPredefinedVariableDocuments[label] = next.vimPredefinedVariableDocuments[label];
                            }
                        });
                        // merge features
                        next.vimFeatureItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.vimFeatureDocuments[label]) {
                                pre.vimFeatureItems.push(item);
                                pre.vimFeatureDocuments[label] = next.vimFeatureDocuments[label];
                            }
                        });
                        // merge expand key words
                        next.vimExpandKeywordItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.expandKeywordDocuments[label]) {
                                pre.vimExpandKeywordItems.push(item);
                                pre.expandKeywordDocuments[label] = next.expandKeywordDocuments[label];
                            }
                        });
                        // merge signature help
                        pre.vimBuiltFunctionSignatureHelp = tslib_1.__assign({}, next.vimBuiltFunctionSignatureHelp, pre.vimBuiltFunctionSignatureHelp);
                        return pre;
                    });
                    server.serialize();
                    return [2 /*return*/];
            }
        });
    });
}
main();
//# sourceMappingURL=build-docs.js.map