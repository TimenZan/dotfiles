"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var path_1 = require("path");
var child_process_1 = tslib_1.__importDefault(require("child_process"));
var rxjs_1 = require("rxjs");
var operators_1 = require("rxjs/operators");
var waitMap_1 = require("rxjs-operators/lib/waitMap");
var diagnostic_1 = require("../handles/diagnostic");
var workspaces_1 = require("./workspaces");
var util_1 = require("../common/util");
var logger_1 = tslib_1.__importDefault(require("../common/logger"));
var log = logger_1.default('parser');
var parserHandles = {};
var indexs = {};
var origin$ = new rxjs_1.Subject();
var scanProcess = child_process_1.default.fork(path_1.join(__dirname, 'scan.js'), ['--node-ipc']);
scanProcess.on('message', function (mess) {
    var data = mess.data, log = mess.log;
    if (data) {
        if (!workspaces_1.workspace.isExistsBuffer(data.uri)) {
            workspaces_1.workspace.updateBuffer(data.uri, data.node);
        }
    }
    if (log) {
        log.info("child_log: " + mess.log);
    }
});
scanProcess.on('error', function (err) {
    log.error("" + (err.stack || err.message || err));
});
function next(textDoc) {
    if (!parserHandles[textDoc.uri]) {
        var uri_1 = textDoc.uri;
        parserHandles[uri_1] = origin$.pipe(operators_1.filter(function (textDoc) { return uri_1 === textDoc.uri; }), operators_1.switchMap(function (textDoc) {
            return rxjs_1.timer(100).pipe(operators_1.map(function () { return textDoc; }));
        }), waitMap_1.waitMap(function (textDoc) {
            return rxjs_1.from(util_1.handleParse(textDoc));
        }, true)).subscribe(function (res) {
            // handle diagnostic
            diagnostic_1.handleDiagnostic(textDoc, res[1]);
            // handle node
            workspaces_1.workspace.updateBuffer(uri_1, res[0]);
            // scan project
            if (!indexs[uri_1]) {
                indexs[uri_1] = true;
                scanProcess.send({
                    uri: uri_1
                });
            }
        }, function (err) {
            log.error("" + (err.stack || err.message || err));
        });
    }
    origin$.next(textDoc);
}
exports.next = next;
function unsubscribe(textDoc) {
    if (parserHandles[textDoc.uri] !== undefined) {
        parserHandles[textDoc.uri].unsubscribe();
    }
    parserHandles[textDoc.uri] = undefined;
}
exports.unsubscribe = unsubscribe;
//# sourceMappingURL=parser.js.map