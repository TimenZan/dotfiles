"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/*
 * vim builtin completion items
 *
 * 1. functions
 * 2. options
 * 3. variables
 * 4. commands
 * 5. has features
 * 6. expand Keyword
 * 7. map args
 */
var fs_1 = require("fs");
var path_1 = tslib_1.__importStar(require("path"));
var fast_glob_1 = tslib_1.__importDefault(require("fast-glob"));
var vscode_languageserver_1 = require("vscode-languageserver");
var util_1 = require("../common/util");
var logger_1 = tslib_1.__importDefault(require("../common/logger"));
var patterns_1 = require("../common/patterns");
var config_1 = tslib_1.__importDefault(require("./config"));
var log = logger_1.default('builtin');
var Builtin = /** @class */ (function () {
    function Builtin() {
        // completion items
        this.vimPredefinedVariablesItems = [];
        this.vimOptionItems = [];
        this.vimBuiltinFunctionItems = [];
        this.vimBuiltinFunctionMap = {};
        this.vimCommandItems = [];
        this.vimMapArgsItems = [];
        this.vimFeatureItems = [];
        this.expandKeywordItems = [];
        this.colorschemeItems = [];
        // signature help
        this.vimBuiltFunctionSignatureHelp = {};
        // documents
        this.vimBuiltFunctionDocuments = {};
        this.vimOptionDocuments = {};
        this.vimPredefinedVariableDocuments = {};
        this.vimCommandDocuments = {};
        this.vimFeatureDocuments = {};
        this.expandKeywordDocuments = {};
    }
    Builtin.prototype.init = function () {
        this.start();
    };
    Builtin.prototype.getPredefinedVimVariables = function () {
        return this.vimPredefinedVariablesItems;
    };
    Builtin.prototype.getVimOptions = function () {
        return this.vimOptionItems;
    };
    Builtin.prototype.getBuiltinVimFunctions = function () {
        return this.vimBuiltinFunctionItems;
    };
    Builtin.prototype.isBuiltinFunction = function (label) {
        return this.vimBuiltinFunctionMap[label];
    };
    Builtin.prototype.getExpandKeywords = function () {
        return this.expandKeywordItems;
    };
    Builtin.prototype.getVimCommands = function () {
        return this.vimCommandItems;
    };
    Builtin.prototype.getVimMapArgs = function () {
        return this.vimMapArgsItems;
    };
    Builtin.prototype.getVimFeatures = function () {
        return this.vimFeatureItems;
    };
    Builtin.prototype.getColorschemes = function () {
        return this.colorschemeItems;
    };
    Builtin.prototype.getSignatureHelpByName = function (name, idx) {
        var params = this.vimBuiltFunctionSignatureHelp[name];
        if (params) {
            return {
                signatures: [{
                        label: name + "(" + params[0] + ")" + (params[1] ? ": " + params[1] : ''),
                        documentation: this.formatVimDocument(this.vimBuiltFunctionDocuments[name]),
                        parameters: params[0].split('[')[0].split(',').map(function (param) {
                            return {
                                label: param.trim()
                            };
                        })
                    }],
                activeSignature: 0,
                activeParameter: idx
            };
        }
        return;
    };
    Builtin.prototype.getDocumentByCompletionItem = function (params) {
        var kind = params.kind;
        switch (kind) {
            case vscode_languageserver_1.CompletionItemKind.Variable:
                if (!this.vimPredefinedVariableDocuments[params.label]) {
                    return;
                }
                return tslib_1.__assign({}, params, { documentation: this.formatVimDocument(this.vimPredefinedVariableDocuments[params.label]) });
            case vscode_languageserver_1.CompletionItemKind.Property:
                if (!this.vimOptionDocuments[params.label]) {
                    return;
                }
                return tslib_1.__assign({}, params, { documentation: this.formatVimDocument(this.vimOptionDocuments[params.label]) });
            case vscode_languageserver_1.CompletionItemKind.Function:
                if (!this.vimBuiltFunctionDocuments[params.label]) {
                    return;
                }
                return tslib_1.__assign({}, params, { documentation: this.formatVimDocument(this.vimBuiltFunctionDocuments[params.label]) });
            case vscode_languageserver_1.CompletionItemKind.EnumMember:
                if (!this.vimFeatureDocuments[params.label]) {
                    return;
                }
                return tslib_1.__assign({}, params, { documentation: this.formatVimDocument(this.vimFeatureDocuments[params.label]) });
            case vscode_languageserver_1.CompletionItemKind.Operator:
                if (!this.vimCommandDocuments[params.label]) {
                    return;
                }
                return tslib_1.__assign({}, params, { documentation: this.formatVimDocument(this.vimCommandDocuments[params.label]) });
            default:
                break;
        }
    };
    Builtin.prototype.getHoverDocument = function (name, pre, next) {
        // builtin variables
        if (util_1.isSomeMatchPattern(patterns_1.builtinVariablePattern, pre) && this.vimPredefinedVariableDocuments[name]) {
            return {
                contents: this.formatVimDocument(this.vimPredefinedVariableDocuments[name])
            };
            // options
        }
        else if (util_1.isSomeMatchPattern(patterns_1.optionPattern, pre) && this.vimOptionDocuments[name.slice(1)]) {
            return {
                contents: this.formatVimDocument(this.vimOptionDocuments[name.slice(1)])
            };
            // builtin functions
        }
        else if (patterns_1.builtinFunctionPattern.test(next) && this.vimBuiltFunctionDocuments[name]) {
            return {
                contents: this.formatVimDocument(this.vimBuiltFunctionDocuments[name])
            };
            // has features
        }
        else if (util_1.isSomeMatchPattern(patterns_1.featurePattern, pre) && this.vimFeatureDocuments[name]) {
            return {
                contents: this.formatVimDocument(this.vimFeatureDocuments[name])
            };
            // expand Keywords
        }
        else if (util_1.isSomeMatchPattern(patterns_1.expandPattern, pre) && this.expandKeywordDocuments["<" + name + ">"]) {
            return {
                contents: this.formatVimDocument(this.expandKeywordDocuments["<" + name + ">"])
            };
            // command
        }
        if (util_1.isSomeMatchPattern(patterns_1.commandPattern, pre) && this.vimCommandDocuments[name]) {
            return {
                contents: this.formatVimDocument(this.vimCommandDocuments[name])
            };
        }
    };
    Builtin.prototype.start = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var runtimepath, _a, err, docs, data;
            var _this = this;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        runtimepath = config_1.default.runtimepath;
                        // get colorschemes
                        if (runtimepath) {
                            this.resolveColorschemes(runtimepath);
                        }
                        // get map args
                        this.resolveMapArgs();
                        return [4 /*yield*/, util_1.pcb(fs_1.readFile)(path_1.join(__dirname, '../../docs/builtin-docs.json'), 'utf-8')];
                    case 1:
                        _a = _b.sent(), err = _a[0], docs = _a[1];
                        if (err) {
                            log.error("[vimls]: read docs/builtin-doc.json fail => " + (err.message || err));
                            return [2 /*return*/];
                        }
                        try {
                            data = JSON.parse(docs);
                            this.vimBuiltinFunctionItems = data.completionItems.functions;
                            this.vimBuiltinFunctionItems.forEach(function (item) {
                                if (!_this.vimBuiltinFunctionMap[item.label]) {
                                    _this.vimBuiltinFunctionMap[item.label] = true;
                                }
                            });
                            this.vimBuiltFunctionDocuments = data.documents.functions;
                            this.vimCommandItems = data.completionItems.commands;
                            this.vimCommandDocuments = data.documents.commands;
                            this.vimPredefinedVariablesItems = data.completionItems.variables;
                            this.vimPredefinedVariableDocuments = data.documents.variables;
                            this.vimOptionItems = data.completionItems.options;
                            this.vimOptionDocuments = data.documents.options;
                            this.vimFeatureItems = data.completionItems.features;
                            this.vimFeatureDocuments = data.documents.features;
                            this.expandKeywordItems = data.completionItems.expandKeywords;
                            this.expandKeywordDocuments = data.documents.expandKeywords;
                            this.vimBuiltFunctionSignatureHelp = data.signatureHelp;
                        }
                        catch (error) {
                            log.error("[vimls]: parse docs/builtin-doc.json fail => " + (error.message || error));
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    // format vim document to markdown
    Builtin.prototype.formatVimDocument = function (document) {
        var indent = 0;
        return {
            kind: vscode_languageserver_1.MarkupKind.Markdown,
            value: [
                '``` help'
            ].concat(document.map(function (line) {
                if (indent === 0) {
                    var m = line.match(/^([ \t]+)/);
                    if (m) {
                        indent = m[1].length;
                    }
                }
                return line.replace(new RegExp("^[ \\t]{" + indent + "}", 'g'), '').replace(/\t/g, '  ');
            }), [
                '```'
            ]).join('\n')
        };
    };
    Builtin.prototype.resolveMapArgs = function () {
        this.vimMapArgsItems = ["<buffer>", "<nowait>", "<silent>", "<script>", "<expr>", "<unique>"]
            .map(function (item) {
            return {
                label: item,
                kind: vscode_languageserver_1.CompletionItemKind.EnumMember,
                documentation: '',
                insertText: item,
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText
            };
        });
    };
    Builtin.prototype.resolveColorschemes = function (runtimepath) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var list, glob, colorschemes, error_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        list = runtimepath;
                        if (config_1.default.vimruntime) {
                            list.push(config_1.default.vimruntime);
                        }
                        glob = runtimepath.map(function (p) { return path_1.default.join(p, 'colors/*.vim'); });
                        colorschemes = [];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, fast_glob_1.default(glob, { onlyFiles: false, deep: 0 })];
                    case 2:
                        colorschemes = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        log.error([
                            "Index Colorschemes Error: " + JSON.stringify(glob),
                            "Error => " + (error_1.stack || error_1.message || error_1)
                        ].join('\n'));
                        return [3 /*break*/, 4];
                    case 4:
                        this.colorschemeItems = colorschemes.map(function (p) {
                            var label = path_1.default.basename(p, '.vim');
                            var item = {
                                label: label,
                                kind: vscode_languageserver_1.CompletionItemKind.EnumMember,
                                insertText: label,
                                insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText
                            };
                            return item;
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    return Builtin;
}());
exports.builtinDocs = new Builtin();
//# sourceMappingURL=builtin.js.map